import { Given, When, Then } from "@wdio/cucumber-framework";
import { expect, browser, $ } from '@wdio/globals';
import dotenv from 'dotenv';
import generatedPage from '../page-objects/generatedPage';
import { setupHealingHooks } from '../utils/healing/healingHooks';
import pageContextManager from '../page-objects/pageContextManager';

dotenv.config();

setupHealingHooks();

/**
 * AUTO-GENERATED STEP DEFINITIONS
 * This file is automatically generated and deduplicated to prevent step pattern conflicts.
 * Each step pattern is unique to ensure proper Cucumber matching.
 * ✅ Multi-page support enabled
 * ✅ Self-healing enabled - will auto-regenerate on step failures
 */

/**
 * the user navigates to to login page
 */
Given(/^the user navigates to to login page$/, async function () {
  try {
    await pageContextManager.getCurrentPage().open();
    await browser.pause(500); // Wait for page to load
  } catch (error) {
    throw new Error(`Failed to navigate: ${error}`);
  }
});

/**
 * the user enters username "student"
 */
When(/^the user enters username "([^"]*)"$/, async function (username) {
  try {
    await pageContextManager.getCurrentPage().username_input.setValue(username);
  } catch (error) {
    throw new Error(`Failed to enter username: ${error}`);
  }
});

/**
 * the user enters password "Password123"
 */
When(/^the user enters password "([^"]*)"$/, async function (password) {
  try {
    await pageContextManager.getCurrentPage().password_input.setValue(password);
  } catch (error) {
    throw new Error(`Failed to enter password: ${error}`);
  }
});

/**
 * the user clicks login button
 */
When(/^the user clicks login button$/, async function () {
  try {
    await pageContextManager.getCurrentPage().submit_button.click();
    await browser.pause(500); // Wait for action
  } catch (error) {
    throw new Error(`Failed to click button: ${error}`);
  }
});

/**
 * the user sees page header containing text "Logged In Successfully"
 */
Then(/^the user sees page header containing text "([^"]*)"$/, async function (expectedText) {
  try {
    const element = pageContextManager.getPage('dashboard').success_text || pageContextManager.getPage('dashboard').message_text;
    await expect(element).toBeDisplayed({ timeout: 5000 });
    const actualMessage = await element.getText();
    expect(actualMessage).toContain(expectedText);
  } catch (error) {
    throw new Error(`Failed to verify message: ${error}`);
  }
});

/**
 * the user sees error message about invalid credentials
 */
Then(/^the user sees error message about invalid credentials$/, async function () {
  try {
    const element = pageContextManager.getCurrentPage().error_text || pageContextManager.getCurrentPage().message_text;
    await expect(element).toBeDisplayed({ timeout: 5000 });
    const actualMessage = await element.getText();
    expect(actualMessage.length).toBeGreaterThan(0);
  } catch (error) {
    throw new Error(`Failed to verify message: ${error}`);
  }
});

/**
 * the user clicks submit button
 */
When(/^the user clicks submit button$/, async function () {
  try {
    await pageContextManager.getCurrentPage().submit_button.click();
    await browser.pause(500); // Wait for action
  } catch (error) {
    throw new Error(`Failed to click button: ${error}`);
  }
});

/**
 * the user sees error message about username format
 */
Then(/^the user sees error message about username format$/, async function () {
  try {
    const element = pageContextManager.getCurrentPage().error_text || pageContextManager.getCurrentPage().message_text;
    await expect(element).toBeDisplayed({ timeout: 5000 });
    const actualMessage = await element.getText();
    expect(actualMessage.length).toBeGreaterThan(0);
  } catch (error) {
    throw new Error(`Failed to verify message: ${error}`);
  }
});

/**
 * the user leaves password field empty
 */
When(/^the user leaves password field empty$/, async function () {
  try {
    await pageContextManager.getCurrentPage().password_input.clearValue();
    await browser.pause(300);
  } catch (error) {
    throw new Error(`Failed to clear field: ${error}`);
  }
});

/**
 * the user sees error message that password is required
 */
Then(/^the user sees error message that password is required$/, async function () {
  try {
    const element = pageContextManager.getCurrentPage().error_text || pageContextManager.getCurrentPage().message_text;
    await expect(element).toBeDisplayed({ timeout: 5000 });
    const actualMessage = await element.getText();
    expect(actualMessage.length).toBeGreaterThan(0);
  } catch (error) {
    throw new Error(`Failed to verify message: ${error}`);
  }
});

