import { Given, When, Then } from '@wdio/cucumber-framework';
import { expect, browser, $ } from '@wdio/globals';
import dotenv from 'dotenv';
import generatedPage from '../page-objects/generatedPage';
import { setupHealingHooks } from '../utils/healing/healingHooks';
import pageContextManager from '../page-objects/pageContextManager';
import {
  safeSetValue,
  safeClick,
  safeIsDisplayed,
  logSelectorUsage,
  getFallbackSelectors,
} from '../utils/healing/selectorHelper';
import { logger } from '../utils/logger';

dotenv.config();

setupHealingHooks();

/**
 * AUTO-GENERATED STEP DEFINITIONS
 * This file is automatically generated and deduplicated to prevent step pattern conflicts.
 * Each step pattern is unique to ensure proper Cucumber matching.
 * ✅ Multi-page support enabled
 * ✅ Self-healing enabled - will auto-regenerate on step failures
 */

/**
 * the user navigates to to login page
 */
Given(/^the user navigates to to login page$/, async function () {
  try {
    await pageContextManager.getCurrentPage().open();
    await browser.pause(500); // Wait for page to load
  } catch (error) {
    throw new Error(`Failed to navigate: ${error}`);
  }
});

/**
 * the user enters username "student"
 */
When(/^the user enters username "([^"]*)"$/, async function (username) {
  try {
    const page = pageContextManager.getCurrentPage();
    const element = page.username_input;
    const selector = element.selector;

    logSelectorUsage('enters username', selector, 'setValue');

    // Check selector exists before attempting action
    const exists = await element.isExisting({ timeout: 3000 }).catch(() => false);
    if (!exists) {
      logger.warn(`Username input selector not found, attempting with fallback`, {
        section: 'STEP_EXECUTION',
        details: { originalSelector: selector },
      });
    }

    await element.setValue(username);
  } catch (error) {
    logger.error('Failed to enter username', error as Error);
    throw new Error(`Failed to enter username: ${error}`);
  }
});

/**
 * the user enters password "Password123"
 */
When(/^the user enters password "([^"]*)"$/, async function (password) {
  try {
    const page = pageContextManager.getCurrentPage();
    const element = page.password_input;
    const selector = element.selector;

    logSelectorUsage('enters password', selector, 'setValue');

    // Check selector exists before attempting action
    const exists = await element.isExisting({ timeout: 3000 }).catch(() => false);
    if (!exists) {
      logger.warn(`Password input selector not found, attempting with fallback`, {
        section: 'STEP_EXECUTION',
        details: { originalSelector: selector },
      });
    }

    await element.setValue(password);
  } catch (error) {
    logger.error('Failed to enter password', error as Error);
    throw new Error(`Failed to enter password: ${error}`);
  }
});

/**
 * the user clicks login button
 */
When(/^the user clicks login button$/, async function () {
  try {
    const page = pageContextManager.getCurrentPage();
    const element = page.submit_button;
    const selector = element.selector;

    logSelectorUsage('clicks login button', selector, 'click');

    // Check selector exists before attempting action
    const exists = await element.isExisting({ timeout: 3000 }).catch(() => false);
    if (!exists) {
      logger.warn(`Submit button selector not found, attempting with fallback`, {
        section: 'STEP_EXECUTION',
        details: {
          originalSelector: selector,
          fallbackSelectors: getFallbackSelectors('login_button'),
        },
      });
    }

    await element.click();
    await browser.pause(500); // Wait for action
  } catch (error) {
    logger.error('Failed to click login button', error as Error);
    throw new Error(`Failed to click button: ${error}`);
  }
});

/**
 * the user sees page header containing text "Logged In Successfully"
 */
Then(/^the user sees page header containing text "([^"]*)"$/, async function (expectedText) {
  try {
    const dashboardPage = pageContextManager.getPage('dashboard');
    const element = dashboardPage.success_text || dashboardPage.message_text;
    const selector = element.selector;

    logSelectorUsage('sees page header containing text', selector, 'check');

    // Check selector exists with detailed logging
    const isDisplayed = await safeIsDisplayed(selector, 'page header containing text');
    if (!isDisplayed) {
      logger.warn(`Success message selector not displayed, checking existence`, {
        section: 'STEP_EXECUTION',
        details: {
          selector,
          expectedText,
          fallbackSelectors: getFallbackSelectors('success_message'),
        },
      });
    }

    await expect(element).toBeDisplayed({ timeout: 5000 });
    const actualMessage = await element.getText();
    expect(actualMessage).toContain(expectedText);
  } catch (error) {
    logger.error(`Failed to verify page header contains "${expectedText}"`, error as Error);
    throw new Error(`Failed to verify message: ${error}`);
  }
});

/**
 * the user sees error message about invalid credentials
 */
Then(/^the user sees error message about invalid credentials$/, async function () {
  try {
    const page = pageContextManager.getCurrentPage();
    const element = page.error_text || page.message_text;
    const selector = element.selector;

    logSelectorUsage('sees error message', selector, 'check');

    // Check selector exists with detailed logging
    const isDisplayed = await safeIsDisplayed(selector, 'error message about invalid credentials');
    if (!isDisplayed) {
      logger.warn(`Error message selector not displayed`, {
        section: 'STEP_EXECUTION',
        details: { selector, fallbackSelectors: getFallbackSelectors('error_message') },
      });
    }

    await expect(element).toBeDisplayed({ timeout: 5000 });
    const actualMessage = await element.getText();
    expect(actualMessage.length).toBeGreaterThan(0);
  } catch (error) {
    logger.error('Failed to verify error message', error as Error);
    throw new Error(`Failed to verify message: ${error}`);
  }
});

/**
 * the user clicks submit button
 */
When(/^the user clicks submit button$/, async function () {
  try {
    const page = pageContextManager.getCurrentPage();
    const element = page.submit_button;
    const selector = element.selector;

    logSelectorUsage('clicks submit button', selector, 'click');

    const exists = await element.isExisting({ timeout: 3000 }).catch(() => false);
    if (!exists) {
      logger.warn(`Submit button selector not found`, {
        section: 'STEP_EXECUTION',
        details: { originalSelector: selector },
      });
    }

    await element.click();
    await browser.pause(500);
  } catch (error) {
    logger.error('Failed to click submit button', error as Error);
    throw new Error(`Failed to click button: ${error}`);
  }
});

/**
 * the user sees error message about username format
 */
Then(/^the user sees error message about username format$/, async function () {
  try {
    const page = pageContextManager.getCurrentPage();
    const element = page.error_text || page.message_text;
    const selector = element.selector;

    logSelectorUsage('sees error message about username format', selector, 'check');

    const isDisplayed = await safeIsDisplayed(selector, 'error message about username format');
    if (!isDisplayed) {
      logger.warn(`Error message selector not displayed`, {
        section: 'STEP_EXECUTION',
        details: { selector },
      });
    }

    await expect(element).toBeDisplayed({ timeout: 5000 });
    const actualMessage = await element.getText();
    expect(actualMessage.length).toBeGreaterThan(0);
  } catch (error) {
    logger.error('Failed to verify username format error message', error as Error);
    throw new Error(`Failed to verify message: ${error}`);
  }
});

/**
 * the user leaves password field empty
 */
When(/^the user leaves password field empty$/, async function () {
  try {
    const page = pageContextManager.getCurrentPage();
    const element = page.password_input;
    const selector = element.selector;

    logSelectorUsage('leaves password field empty', selector, 'check');

    const exists = await element.isExisting({ timeout: 3000 }).catch(() => false);
    if (!exists) {
      logger.warn(`Password input selector not found`, {
        section: 'STEP_EXECUTION',
        details: { selector },
      });
    }

    await element.clearValue();
    await browser.pause(300);
  } catch (error) {
    logger.error('Failed to clear password field', error as Error);
    throw new Error(`Failed to clear field: ${error}`);
  }
});

/**
 * the user sees error message that password is required
 */
Then(/^the user sees error message that password is required$/, async function () {
  try {
    const page = pageContextManager.getCurrentPage();
    const element = page.error_text || page.message_text;
    const selector = element.selector;

    logSelectorUsage('sees error message that password is required', selector, 'check');

    const isDisplayed = await safeIsDisplayed(selector, 'error message that password is required');
    if (!isDisplayed) {
      logger.warn(`Error message selector not displayed`, {
        section: 'STEP_EXECUTION',
        details: { selector },
      });
    }

    await expect(element).toBeDisplayed({ timeout: 5000 });
    const actualMessage = await element.getText();
    expect(actualMessage.length).toBeGreaterThan(0);
  } catch (error) {
    logger.error('Failed to verify password required error message', error as Error);
    throw new Error(`Failed to verify message: ${error}`);
  }
});
